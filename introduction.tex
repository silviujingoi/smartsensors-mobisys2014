
\section{\label{sec:Introduction}Introduction}

Smart phones and tablets are overwhelmingly used today to run
interactive foreground applications, such as games and web browsers.
As a result, current mobile devices are optimized for a use case where
applications are used intermittently during the day in sessions that
last several minutes.  For example, Alice takes a little break to pick
up her phone, check the weather, read the latest news story and play a
game for a few minutes, and then puts it away to go back to work.  To
maximize battery life, current mobile devices are engineered to go into
sleep state for most of the day when they are not supporting
interactive usage.

Unfortunately, most mobile platforms are a poor match for a growing
class of mobile applications that perform continuous background
sensing.  Examples range from medical and health monitoring
applications, such as pedometers and fall detectors, to participatory
sensing applications, such as pollution and traffic monitoring.  While
the processing demands of these applications is modest most of the
time, they require the periodic collection of sensor readings which
prevents the device from going to sleep for extended periods of time.
As a result, applications that perform continuous sensing may cause
the device's battery to drain within several hours.

To improve support for continuous sensing applications the research
community has proposed the use of fully programmable heterogeneous
architectures~\cite{reflex}.  In these approaches, developers
partition their applications to offload the initial filtering stages
of the application to a low-power processor (or a hierarchy of
processors).  When the code running on the low power processor detects
the occurrence of event of interest, it proceeds to wake up the phone
and passes control to the rest of the application.  While the ability
to run custom code on the low-power hardware provides great
flexibility, the significant complexity inherent in this approach has
prevent (so far) its adoption in commercial devices.  Instead,
smartphone manufacturers have recently incorporated low-power
processors into their architectures, but have limited application
developers to APIs that provide fixed functionality, including
batching sensor readings and recognizing a small number of predefined
activities that can be used as {\em wake up} conditions.

In this paper we argue that these APIs are insufficient in order to
support a rich and flexible set of continuous monitoring applications.
Batching is inefficient for applications that depend on infrequent
events and is not appropriate for applications that require crisp
response time.  On the other hand, an API based on activity
recognition provides little flexibility with no support for
applications interested in events that are not covered by the set of
predefined activities.  Instead, we argue that the API should expose
access to filter-level functionality, enabling programmers to chose
among a set of predefined filters that implement commonly used
algorithms (e.g., FFT, exponential average) with parameters that can
be configured by the developer to meet application requirements.  By
providing access to lower-level filters, as oppose to higher-level
activity detectors, our approach provides a better balance between
flexibility and ease of deployment.  By letting the developer select
and configure the filtering algorithm used by the low-power hardware,
our approach empowers developers to design a broad set of wake up
conditions that can be used to detect a wide range of activities.
This functionality could be leveraged by user-level activity
recognition libraries that could then provide simple wake up
conditions for a large number of activities.

To evaluate the benefits of our approach we developed a prototype
implementation that extends a Nexus 4 phone with a low-power sensor
board.  Our experiments with various accelerometer-based applications
show that: {\em TODO} summarize results.

The rest of this paper is organized as follows.
Section~\ref{sec:background}, discusses existing approaches to
continuous sensing and their limitations.  Section~\ref{sec:approach}
introduces our new approach for continuous monitoring, which lets
developers configure the filters used to implement wake up conditions.
Section~\ref{sec:prototype} describes our Nexus 4-based prototype.
Sections~\ref{sec:experimentalSetup} and~\ref{sec:results} present our
experimental setup and the results from our evaluation.  Finally,
Sections~\ref{sec:related} and~\ref{sec:conclusions} describe our work
in the context of related work and conclude the paper.

