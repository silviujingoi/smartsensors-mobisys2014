\section{Experimental Setup}
\label{sec:experimentalSetup}

While our robotic testbed allows for live experiments, we chose
instead to use the robot to collect traces and to compare sensing
implementations using trace base simulation.  We opted for this
approach for several reasons.  First, it took the robot close to an
hour to complete a single experiment.  A thorough exploration of the
configuration space of the various sensing approaches would have
required over a year of continuous live experiments.  Moreover, taking
fine grain power consumption measurements while the robot is in motion
is not trivial.

We collected our traces by having the robot perform multiple runs with
a prototype smartphone attached to it back.  The smartphone ran an
application that kept the device always awake and continuously recorded
accelerometer readings for all three axises.  Each run generated a
trace that included timestamps for the start and end of each action
performed by the robot (which we use as the ground truth for our
experiments) and a list of timestamped acceleration readings.

In each run, the robot performed five different actions: standing
idle, walking, sit-to-stand transitions, stand-to-sit transitions, and
headbutt.  We created runs with three different levels of activity.
Runs in groups 1, 2 and 3 spent 90\% , 50\% and 10\% of the time
standing idle, respectively. The reminder of the time was allocated as
follows: 73\% for walking, 24\% for transitions between sitting and
standing, and 3\% for headbutts.  This set-up allows us to experiment
with detecting actions that are common, somewhat frequent, and rare.
In total, the robot executed 18 different runs: 9 for the group 1, 6
for group 2 and 3 for group 3.  We generated more runs for groups 1
and 2 because of the lower activity levels compared to group 3. To
eliminate bias, the list of actions was generated randomly for each
run, based on the expected probabilities of each action occurring.

The simulator evaluated each trace for each of the following sensing
configurations:


\textbf{Always Awake} Provides a baseline for the following
  methods in terms of event detection recall and precision.

\textbf{Duty cycling} A software-only solution that checks
  sensor readings periodically and then puts the phone to sleep. This
  method can be implemented on any mobile device and does not require
  special hardware support.

\textbf{Batching} A hardware extension to duty
  cycling method that matches the Always Awake method in terms of
  detection recall and precision, but is expected to consume less
  power.

\textbf{Activity} Assumes hardware support for
  activity detection, specifically a step detector.  Allows the
  exploration of the benefits of hardware-based activity recognition
  as a wake-up condition.

\textbf{Filter} Assumes hardware
  support for the selection of a pre-defined data filter and
  customization of filter and wake-up parameters. Allows us to explore
  the benefits of filter customization.

\textbf{Oracle} A hypothetical, ideal wake-up condition. The
  device only wakes up when there exists an event of interest to be
  recognized. Such a wake-up condition would achieve the same
  detection precision and recall as Always Awake, with the lowest
  possible energy consumption. The difference between the power
  consumption of this method and the method using custom filter-based
  wake-up conditions gives an upper bound on the potential benefits of
  fully configurable hardware, beyond limited data filter selection.

  The simulator replays the collected traces for each of the
  applications described in Section~\ref{sec:application} and each of
  the above sensing strategies, and determines the the amount of time
  the smartphone is awake and asleep and the total number of wake-ups.
  In addition, for each application the simulator determines its
  recall~\footnote{$Recall=TruePositives/(TruePositives+FalseNegatives)$}
  and
  precision~\footnote{$Precision=TruePositives/(TruePositives+FalsePositives)$}. Finally, using an energy model derived from measurements of our
  smartsensor prototype, the simulator estimated the average power
  consumption of each configuration.  For {\em Always Awake} and {\em
    Duty Cycling}, the power model accounts only for the energy
  consumption of the Nexus 4.  For {\em Batching} and {\em Activity}
  the model also includes the cost of the simple TI MSP430
  micro-controller.  Finally, {\em Filter} and {\em Oracle} include
  the cost either the TI MSP430 or TI Stellaris LM4F120H5QR, depending
  on the condition being evaluated.








